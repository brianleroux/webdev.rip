<hd-article>
  <p>By instinct when faced with a problem we often grasp for solutions before fully understanding or appreciating the given problem. This missing context is often the source of new problems we didn't initially anticipate. Now we have more than one problem.</p>

  <blockquote>“The major cause of problems are solutions.” &#8212; Eric Sevareid</blockquote>

  <p>The easiest way to eliminate conditions of a given problem is stop doing the thing that creates the problem. The classic joke "doctor, it hurts when I do this" and the doctor replies "well, stop doing that" is deep wisdom. Programmers love the acronym <a href=https://en.wikipedia.org/wiki/You_aren%27t_gonna_need_it>YAGNI</a> (you ain't gonna need it) but we tend to practise the idea a lot less than we say it.</p>

  <h2>Undifferentiated Heavy Lifting</h2>
  <p><em>Undifferentiated heavy lifting</em> is a term often used in the context of cloud computing. It refers to the necessary but repetitive and non-differentiating tasks that companies must handle to maintain their cloud infrastructure. This can include managing servers, scaling databases, ensuring security compliance, and other foundational tasks that consume valuable time and resources but don't directly contribute to a company's unique value proposition.</p>

  <p>In essence, the idea promotes identifying what really matters for your business's growth and outsourcing as much as possible to cloud services to create as much space as possible to focus on what you do best, which likely <strong>is not</strong> managing infrastructure. Said plainly, a sneaker manufacturer should not manage data centers. Taken to a logical extreme this shoe company might only write extremely high level code leaving behind all the concepts of physical infrastructure to the vendor never losing cycles to configuring networks, patching operating systems, or replacing hardware.</p>

  <p>This idea of eliminating undifferentiated work does not have to be solely about cloud infrastructure. <strong>It feels kinda scary</strong> but embracing programming minimalism can significantly enhance productivity. Limitations absolutely foster creativity. Instead of adding another dependency can we use the native runtime platform? Maybe you can use the built-in <code>node:test</code> module instead of bringing in another library, and the maintenance burden that implicitly creates? Could we  consider <a href=https://syntax.fm/show/719/fullstack-typescript-apps-with-no-build-step-with-brian-leroux>JSDoc for TypeScript</a> instead of struggling with hard-to-debug artifacts of lossy transpiling? What are the <a href=https://github.com/brianleroux/webdev.rip/tree/main/app/elements/hd>merits of writing HTML</a> instead of compiling it from a non-standard higher level dialect? Are the tradeoffs worth it? What can we remove?</p>

  <h2>The Best Solution</h2>
  <p style="background-color:rgb(255, 255, 102, 10%);">The best solution to a problem is eliminating the conditions that create that problem rather than adding another solution that creates new unique problems.</p>
</hd-article>
